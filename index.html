<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>초등 읽기 비공식 검사 도구</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* Custom CSS (style.css 내용에 해당) */
        body {
            font-family: 'Inter', sans-serif; /* Tailwind 기본 폰트와 유사하게 설정 */
            margin: 0;
            min-height: 100vh;
            background-color: #f0f4f8; /* 기본 배경색 */
        }
        #root {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem; /* 전체적인 패딩 추가하여 화면 가장자리에 붙는 것 방지 */
        }
        /* PDF 출력 시 특정 요소 숨기기 */
        .no-print {
            /* Tailwind 클래스로 제어하므로 여기서는 특별히 필요 없을 수 있음 */
        }
        /* PDF 상세 내용 2단 레이아웃용 (JS에서 동적 제어) */
        .pdf-detail-content-area-columns {
            columns: 2;
            column-gap: 10mm; /* Adjust as needed */
            width: auto; /* Or 100% depending on parent */
        }
        .response-item-pdf, .break-inside-avoid {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
        }
        /* 로딩 메시지 스타일 */
        .loading-message {
            text-align: center;
            font-size: 1.25rem; /* text-xl */
            color: #4a5568; /* text-gray-700 */
            padding: 2rem; /* p-8 */
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="root">
        <div class="loading-message">검사 도구를 불러오는 중입니다...</div>
    </div>

    <script>
        // 이 값들은 실제 Canvas 환경에서 제공되는 값으로 대체되어야 합니다.
        // 개발/테스트 목적으로 임시 값을 사용할 수 있습니다.
        var __app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id-html';
        var __firebase_config_str = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
        var __initial_auth_token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    </script>

    <script type="text/babel">
        // =============== JavaScript (script.js 내용에 해당) ===============

        // --- wordData (기존 React 코드에서 가져옴) ---
        const wordData = {
          meaningRegularNoFinalConsonant: [
            { id: 'mrnfc1', word: '나무', pronunciation: '나-무' }, { id: 'mrnfc2', word: '바다', pronunciation: '바-다' },
            { id: 'mrnfc3', word: '고기', pronunciation: '고-기' }, { id: 'mrnfc4', word: '소리', pronunciation: '소-리' },
            { id: 'mrnfc5', word: '새우', pronunciation: '새-우' }, { id: 'mrnfc6', word: '포도', pronunciation: '포-도' },
            { id: 'mrnfc7', word: '가위', pronunciation: '가-위' }, { id: 'mrnfc8', word: '모자', pronunciation: '모-자' },
            { id: 'mrnfc9', word: '치마', pronunciation: '치-마' }, { id: 'mrnfc10', word: '오리', pronunciation: '오-리' },
          ],
          meaningRegularWithFinalConsonant: [
            { id: 'mrwfc1', word: '연필', pronunciation: '연-필' }, { id: 'mrwfc2', word: '운동', pronunciation: '운-동' },
            { id: 'mrwfc3', word: '신발', pronunciation: '신-발' }, { id: 'mrwfc4', word: '공책', pronunciation: '공-책' },
            { id: 'mrwfc5', word: '연극', pronunciation: '연-극' }, { id: 'mrwfc6', word: '창문', pronunciation: '창-문' },
            { id: 'mrwfc7', word: '선물', pronunciation: '선-물' }, { id: 'mrwfc8', word: '식탁', pronunciation: '식-탁' },
            { id: 'mrwfc9', word: '점심', pronunciation: '점-심' }, { id: 'mrwfc10', word: '풍선', pronunciation: '풍-선' },
          ],
          meaningIrregular: [
            { id: 'mi1', rule: '음절의 끝소리 규칙', word: '밖', pronunciation: '[박]' }, { id: 'mi2', rule: '음절의 끝소리 규칙', word: '낮', pronunciation: '[낟]' },
            { id: 'mi3', rule: '음절의 끝소리 규칙', word: '솥', pronunciation: '[솓]' }, { id: 'mi4', rule: '음절의 끝소리 규칙', word: '부엌', pronunciation: '[부억]' },
            { id: 'mi5', rule: '음절의 끝소리 규칙', word: '옷', pronunciation: '[옫]' }, { id: 'mi6', rule: '자음동화', word: '신라', pronunciation: '[실라]' },
            { id: 'mi7', rule: '자음동화', word: '국물', pronunciation: '[궁물]' }, { id: 'mi8', rule: '자음동화', word: '독립', pronunciation: '[동닙]' },
            { id: 'mi9', rule: '자음동화', word: '백마', pronunciation: '[뱅마]' }, { id: 'mi10', rule: '자음동화', word: '닫는', pronunciation: '[단는]' },
            { id: 'mi11', rule: '구개음화', word: '같이', pronunciation: '[가치]' }, { id: 'mi12', rule: '구개음화', word: '굳이', pronunciation: '[구지]' },
            { id: 'mi13', rule: '구개음화', word: '해돋이', pronunciation: '[해도지]' }, { id: 'mi14', rule: '구개음화', word: '밭이', pronunciation: '[바치]' },
            { id: 'mi15', rule: '구개음화', word: '미닫이', pronunciation: '[미다지]' }, { id: 'mi16', rule: '경음화', word: '국밥', pronunciation: '[국빱]' },
            { id: 'mi17', rule: '경음화', word: '학교', pronunciation: '[학꾜]' }, { id: 'mi18', rule: '경음화', word: '책상', pronunciation: '[책쌍]' },
            { id: 'mi19', rule: '경음화', word: '덮개', pronunciation: '[덥깨]' }, { id: 'mi20', rule: '경음화', word: '읽고', pronunciation: '[일꼬]' },
            { id: 'mi21', rule: 'ㄴ첨가', word: '솜이불', pronunciation: '[솜니불]' }, { id: 'mi22', rule: 'ㄴ첨가', word: '막일', pronunciation: '[망닐]' },
            { id: 'mi23', rule: 'ㄴ첨가', word: '내복약', pronunciation: '[내봉냑]' }, { id: 'mi24', rule: 'ㄴ첨가', word: '한여름', pronunciation: '[한녀름]' },
            { id: 'mi25', rule: 'ㄴ첨가', word: '담요', pronunciation: '[담뇨]' }, { id: 'mi26', rule: 'ㅎ탈락', word: '좋아', pronunciation: '[조아]' },
            { id: 'mi27', rule: 'ㅎ탈락', word: '많이', pronunciation: '[마니]' }, { id: 'mi28', rule: 'ㅎ탈락', word: '놓아', pronunciation: '[노아]' },
            { id: 'mi29', rule: 'ㅎ탈락', word: '쌓아', pronunciation: '[싸아]' }, { id: 'mi30', rule: 'ㅎ탈락', word: '닿아', pronunciation: '[다아]' },
            { id: 'mi31', rule: '자음 축약', word: '놓고', pronunciation: '[노코]' }, { id: 'mi32', rule: '자음 축약', word: '좋지', pronunciation: '[조치]' },
            { id: 'mi33', rule: '자음 축약', word: '입학', pronunciation: '[이팍]' }, { id: 'mi34', rule: '자음 축약', word: '좁히다', pronunciation: '[조피다]' },
            { id: 'mi35', rule: '자음 축약', word: '각하', pronunciation: '[가카]' }, { id: 'mi41', rule: '자음군 단순화', word: '닭', pronunciation: '[닥]' },
            { id: 'mi42', rule: '자음군 단순화', word: '값', pronunciation: '[갑]' }, { id: 'mi43', rule: '자음군 단순화', word: '읽다', pronunciation: '[익따]' },
            { id: 'mi44', rule: '자음군 단순화', word: '앉다', pronunciation: '[안따]' }, { id: 'mi45', rule: '자음군 단순화', word: '몫', pronunciation: '[목]' },
          ],
        };

        // --- React 컴포넌트들 (기존 코드에서 가져옴) ---
        const { useState, useEffect, useRef } = React;

        // Introduction component
        const Introduction = ({ onStart }) => {
          return (
            <div className="p-6 bg-white rounded-xl shadow-lg w-full max-w-2xl mx-auto my-8">
              <h2 className="text-3xl font-bold text-gray-800 mb-4 text-center">읽기 비공식 검사 도구</h2>
              <div className="text-gray-700 space-y-4 mb-8">
                <p>
                  이 도구는 초등학교 1~3학년 아동의 비공식적인 읽기 능력을 평가하기 위해 제작되었습니다.
                  세 가지 주요 영역(의미 규칙 단어 - 받침 없는 단어, 의미 규칙 단어 - 받침 있는 단어, 의미 불규칙 단어)으로
                  구성되어 있으며, 각 영역별로 아동의 단어인지 능력을 확인할 수 있습니다.
                </p>
                <h3 className="text-xl font-semibold text-gray-800 mt-6">검사 목적</h3>
                <ul className="list-disc list-inside ml-4 space-y-1">
                  <li>아동의 모음 및 자음 인식 능력 확인</li>
                  <li>받침 있는 단어의 정확한 읽기 능력 평가</li>
                  <li>다양한 음운 변동 규칙이 적용된 단어의 읽기 능력 진단</li>
                </ul>
                <h3 className="text-xl font-semibold text-gray-800 mt-6">적용 및 해석 방법</h3>
                <ul className="list-disc list-inside ml-4 space-y-1">
                  <li>
                    <strong>검사 진행:</strong> 각 단어를 아동에게 제시하고, 아동이 단어를 읽는 것을 관찰합니다.
                    '정반응' 또는 '오반응'을 체크하고, 아동의 실제 발음이나 특이 사항을 '아동 반응 기록' 칸에 기록합니다.
                  </li>
                  <li>
                    <strong>결과 산출:</strong> 모든 문항 90% 이상 수행 시 '습득'으로 결과가 자동 산출됩니다.
                  </li>
                  <li>
                    <strong>결과 활용:</strong> 산출된 결과를 바탕으로 아동이 어떤 읽기 영역에서 강점과 약점을 가지고 있는지 파악할 수 있습니다.
                    '미습득'으로 판정된 영역은 추가적인 개입이나 지도가 필요함을 의미합니다.
                  </li>
                </ul>
              </div>
              <button
                onClick={onStart}
                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105"
              >
                검사 시작하기
              </button>
            </div>
          );
        };

        const PersonalInfo = ({ personalInfo, setPersonalInfo, onNext }) => {
          const handleChange = (e) => {
            const { name, value } = e.target;
            setPersonalInfo((prev) => ({ ...prev, [name]: value }));
          };

          return (
            <div className="p-6 bg-white rounded-xl shadow-lg w-full max-w-2xl mx-auto my-8">
              <h2 className="text-2xl font-bold text-gray-800 mb-6 text-center">학생 인적 사항</h2>
              <div className="mb-4">
                <label htmlFor="name" className="block text-gray-700 text-sm font-semibold mb-2">이름:</label>
                <input
                  type="text"
                  id="name"
                  name="name"
                  value={personalInfo.name}
                  onChange={handleChange}
                  className="shadow-sm appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-400"
                  placeholder="학생의 이름을 입력하세요"
                />
              </div>
              <div className="mb-6">
                <label htmlFor="grade" className="block text-gray-700 text-sm font-semibold mb-2">학년:</label>
                <input
                  type="number"
                  id="grade"
                  name="grade"
                  value={personalInfo.grade}
                  onChange={handleChange}
                  min="1"
                  max="3"
                  className="shadow-sm appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-400"
                  placeholder="학년을 입력하세요 (1-3)"
                />
              </div>
              <button
                onClick={onNext}
                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105"
              >
                검사 진행
              </button>
            </div>
          );
        };

        const WordSection = ({ title, description, words, responses, setResponses, onNext, onPrevious }) => {
          const handleResponseChange = (id, type, value) => {
            setResponses((prev) => ({
              ...prev,
              [id]: {
                ...prev[id],
                [type]: value,
              },
            }));
          };

          return (
            <div className="p-6 bg-white rounded-xl shadow-lg w-full max-w-2xl mx-auto my-8">
              <h2 className="text-2xl font-bold text-gray-800 mb-4 text-center">{title}</h2>
              <p className="text-gray-600 mb-6 text-center">{description}</p>
              <div className="space-y-4">
                {words.map((item, index) => (
                  <div key={item.id} className="flex flex-col p-4 bg-gray-50 rounded-lg shadow-sm">
                    <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-2">
                      <div className="flex-grow flex items-center w-full sm:w-auto mb-2 sm:mb-0">
                        <span className="text-lg font-bold text-gray-700 mr-3">{index + 1}.</span>
                        <span className="text-xl font-semibold text-gray-900">{item.word}</span>
                        {item.rule && <span className="text-sm text-gray-500 ml-2">({item.rule})</span>}
                        <span className="text-sm text-gray-500 ml-2">({item.pronunciation})</span>
                      </div>
                      <div className="flex items-center space-x-3 self-start sm:self-center">
                        <label className="inline-flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            className="form-checkbox h-5 w-5 text-green-600 rounded-md focus:ring-green-500"
                            checked={responses[item.id]?.isCorrect === true}
                            onChange={() => handleResponseChange(item.id, 'isCorrect', true)}
                          />
                          <span className="ml-2 text-gray-700">정반응</span>
                        </label>
                        <label className="inline-flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            className="form-checkbox h-5 w-5 text-red-600 rounded-md focus:ring-red-500"
                            checked={responses[item.id]?.isCorrect === false}
                            onChange={() => handleResponseChange(item.id, 'isCorrect', false)}
                          />
                          <span className="ml-2 text-gray-700">오반응</span>
                        </label>
                      </div>
                    </div>
                    <textarea
                      value={responses[item.id]?.notes || ''}
                      onChange={(e) => handleResponseChange(item.id, 'notes', e.target.value)}
                      placeholder="아동 반응 기록 (예: '나모'라고 읽음)"
                      rows="1"
                      className="mt-2 p-2 border border-gray-300 rounded-md w-full text-sm focus:outline-none focus:ring-2 focus:ring-blue-400 resize-none"
                    ></textarea>
                  </div>
                ))}
              </div>
              <div className="flex justify-between mt-8">
                {onPrevious && (
                  <button
                    onClick={onPrevious}
                    className="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105"
                  >
                    이전
                  </button>
                )}
                <button
                  onClick={onNext}
                  className="ml-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105"
                >
                  다음
                </button>
              </div>
            </div>
          );
        };

        const Results = ({ personalInfo, responses, onRestart, wordDataFromApp }) => {
          const resultsSummaryRef = useRef();
          const resultsDetailRef = useRef(); 

          const calculateSectionStats = (sectionWords, thresholdPercentage) => {
            const totalCount = sectionWords.length;
            if (totalCount === 0) return { status: '데이터 없음', correctCount: 0, totalCount: 0 };
            const correctCount = sectionWords.filter(word => responses[word.id]?.isCorrect === true).length;
            const percentage = (correctCount / totalCount) * 100;
            const status = percentage >= thresholdPercentage ? '습득' : '미습득';
            return { status, correctCount, totalCount };
          };

          const meaningRegularNoFinalConsonantStats = calculateSectionStats(wordDataFromApp.meaningRegularNoFinalConsonant, 90);
          const meaningRegularWithFinalConsonantStats = calculateSectionStats(wordDataFromApp.meaningRegularWithFinalConsonant, 90);

          const irregularRules = {};
          wordDataFromApp.meaningIrregular.forEach(word => {
            if (!irregularRules[word.rule]) irregularRules[word.rule] = [];
            irregularRules[word.rule].push(word);
          });

          const irregularResults = Object.keys(irregularRules).map(rule => {
            const stats = calculateSectionStats(irregularRules[rule], 90);
            return { rule, status: stats.status, correctCount: stats.correctCount, totalCount: stats.totalCount };
          });
          
          const generateOverallSummaryText = () => {
            let summaryParts = [];
            let strengths = [];
            let weaknesses = [];

            if (meaningRegularNoFinalConsonantStats.status === '습득') strengths.push("받침 없는 규칙 단어"); else weaknesses.push("받침 없는 규칙 단어");
            if (meaningRegularWithFinalConsonantStats.status === '습득') strengths.push("받침 있는 규칙 단어"); else weaknesses.push("받침 있는 규칙 단어");

            const irregularAcquiredCount = irregularResults.filter(r => r.status === '습득').length;
            const irregularTotalCount = irregularResults.length;
            if (irregularTotalCount > 0) {
                if (irregularAcquiredCount === irregularTotalCount) strengths.push("모든 음운 변동 규칙");
                else {
                    irregularResults.forEach(r => {
                        if (r.status === '습득') strengths.push(`${r.rule} 규칙`);
                        else weaknesses.push(`${r.rule} 규칙`);
                    });
                }
            }

            if (weaknesses.length === 0 && strengths.length > 0) {
                summaryParts.push(`전반적으로 모든 평가 영역에서 우수한 단어 인지 능력을 보였습니다.`);
            } else {
                if (strengths.length > 0) summaryParts.push(`다음 영역에서 강점을 보입니다: ${strengths.join(', ')}.`);
                if (weaknesses.length > 0) summaryParts.push(`다음 영역에서 추가적인 지도 및 연습이 권장됩니다: ${weaknesses.join(', ')}.`);
            }
            if (summaryParts.length === 0) return "평가 결과를 바탕으로 아동의 읽기 능력을 분석해주세요.";
            return summaryParts.join(" ");
          };


          const generatePdf = async () => {
            if (!window.html2canvas || !window.jspdf) {
              alert("PDF 내보내기 라이브러리가 로드되지 않았습니다."); return;
            }
            const summaryInput = resultsSummaryRef.current; 
            const detailSectionContainer = resultsDetailRef.current; 
            const detailContentArea = detailSectionContainer.querySelector('.pdf-detail-content-area');


            if (!summaryInput || !detailSectionContainer || !detailContentArea) {
              alert("PDF 생성에 필요한 요소를 찾을 수 없습니다."); return;
            }
            
            // Capture original style *before* try block
            const originalDetailContentAreaStyle = detailContentArea.style.cssText;

            document.querySelectorAll('.no-print').forEach(btn => btn.style.display = 'none');
            const pdf = new window.jspdf.jsPDF('p', 'mm', 'a4');
            const pdfPageWidth = pdf.internal.pageSize.getWidth();
            const pdfPageHeight = pdf.internal.pageSize.getHeight();
            const margin = 10;
            const contentPdfWidth = pdfPageWidth - (2 * margin);
            const contentPdfHeightOnPage = pdfPageHeight - (2 * margin);
            const html2canvasBaseOptions = { 
                scale: 1.5, 
                useCORS: true, 
                logging: false, 
                scrollY: 0, 
            };
            let currentPage = 1;
            const maxPages = 4;
            let yPositionOnPdf = margin; 

            try {
                // 1. 요약 정보 캡처 및 첫 페이지에 추가
                const summaryCanvas = await window.html2canvas(summaryInput, {
                    ...html2canvasBaseOptions, 
                    width: summaryInput.scrollWidth,
                    height: summaryInput.scrollHeight
                });
                const summaryImgData = summaryCanvas.toDataURL('image/png');
                let summaryImgHeightInPdf = summaryCanvas.height * (contentPdfWidth / summaryCanvas.width);
                
                if (summaryImgHeightInPdf > contentPdfHeightOnPage) { 
                    pdf.addImage(summaryImgData, 'PNG', margin, margin, contentPdfWidth, contentPdfHeightOnPage);
                    summaryImgHeightInPdf = contentPdfHeightOnPage; 
                    if (currentPage < maxPages) {
                        pdf.addPage();
                        currentPage++;
                        yPositionOnPdf = margin; 
                    } else {
                         pdf.setPage(maxPages);
                         pdf.setFontSize(10); pdf.setTextColor(100);
                         const truncatedMsg = "... (요약 내용이 너무 길어 일부만 표시됩니다) ...";
                         const textWidth = pdf.getStringUnitWidth(truncatedMsg) * pdf.getFontSize() / pdf.internal.scaleFactor;
                         pdf.text(truncatedMsg, (pdfPageWidth - textWidth) / 2, contentPdfHeightOnPage + margin - 5);
                         pdf.save(`읽기검사결과_${personalInfo.name || '아동'}_${new Date().toLocaleDateString('ko-KR').replace(/\s/g, '')}.pdf`);
                         document.querySelectorAll('.no-print').forEach(btn => btn.style.display = '');
                         return;
                    }
                } else {
                    pdf.addImage(summaryImgData, 'PNG', margin, margin, contentPdfWidth, summaryImgHeightInPdf);
                }
                
                if (currentPage < maxPages) { 
                    if (currentPage === 1) { 
                        pdf.addPage();
                        currentPage++;
                    }
                } else if (currentPage >= maxPages && summaryImgHeightInPdf >= contentPdfHeightOnPage) { 
                    pdf.save(`읽기검사결과_${personalInfo.name || '아동'}_${new Date().toLocaleDateString('ko-KR').replace(/\s/g, '')}.pdf`);
                    document.querySelectorAll('.no-print').forEach(btn => btn.style.display = '');
                    return;
                }
                yPositionOnPdf = margin; 


                // 2단 레이아웃을 위해 임시 스타일 적용
                detailContentArea.style.columns = '2';
                detailContentArea.style.columnGap = '8mm'; 
                detailContentArea.style.width = '100%'; 
                
                await new Promise(resolve => setTimeout(resolve, 50));

                const detailCanvas = await window.html2canvas(detailSectionContainer, {
                    ...html2canvasBaseOptions,
                    width: detailSectionContainer.scrollWidth, 
                    height: detailSectionContainer.scrollHeight 
                });

                // 스타일 복원 (캡처 후 즉시)
                // 이 줄은 finally 블록에서도 실행되지만, 여기서 먼저 실행하여 UI를 빠르게 복원합니다.
                // generatePdf 함수 가장 바깥쪽 finally 블록에서 한 번 더 복원하여 오류 발생 시에도 확실히 복원되도록 합니다.
                // detailContentArea.style.cssText = originalDetailContentAreaStyle; // 중복될 수 있으므로 finally에서만 처리

                const detailImgOriginalWidth = detailCanvas.width;
                const detailImgOriginalHeight = detailCanvas.height;
                const pdfImageWidth = contentPdfWidth;

                let currentYInOriginalImagePx = 0; 

                while (currentYInOriginalImagePx < detailImgOriginalHeight && currentPage <= maxPages) {
                    let availableHeightOnPdfPage = contentPdfHeightOnPage - yPositionOnPdf;

                    if (availableHeightOnPdfPage <= 0) { 
                        if (currentPage >= maxPages) break; 
                        pdf.addPage();
                        currentPage++;
                        yPositionOnPdf = margin; 
                        availableHeightOnPdfPage = contentPdfHeightOnPage - yPositionOnPdf;
                    }

                    let heightToDrawFromOriginalPx = availableHeightOnPdfPage * (detailImgOriginalWidth / pdfImageWidth);
                    heightToDrawFromOriginalPx = Math.min(heightToDrawFromOriginalPx, detailImgOriginalHeight - currentYInOriginalImagePx);

                    if (heightToDrawFromOriginalPx <= 0) break;
                    
                    const actualChunkHeightOnPdf = heightToDrawFromOriginalPx * (pdfImageWidth / detailImgOriginalWidth);

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = detailImgOriginalWidth;
                    tempCanvas.height = heightToDrawFromOriginalPx;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(detailCanvas, 0, currentYInOriginalImagePx, detailImgOriginalWidth, heightToDrawFromOriginalPx, 0, 0, detailImgOriginalWidth, heightToDrawFromOriginalPx);
                    const croppedImgData = tempCanvas.toDataURL('image/png');

                    pdf.addImage(croppedImgData, 'PNG', margin, yPositionOnPdf, pdfImageWidth, actualChunkHeightOnPdf);

                    currentYInOriginalImagePx += heightToDrawFromOriginalPx;
                    yPositionOnPdf += actualChunkHeightOnPdf + 2; 
                }

                if (currentYInOriginalImagePx < detailImgOriginalHeight && currentPage >= maxPages) {
                    pdf.setPage(maxPages); 
                    pdf.setFontSize(10);
                    pdf.setTextColor(100);
                    const truncatedMsg = "... (내용이 많아 일부만 표시됩니다) ...";
                    const textWidth = pdf.getStringUnitWidth(truncatedMsg) * pdf.getFontSize() / pdf.internal.scaleFactor;
                    pdf.text(truncatedMsg, (pdfPageWidth - textWidth) / 2, contentPdfHeightOnPage + margin - 5);
                }

                pdf.save(`읽기검사결과_${personalInfo.name || '아동'}_${new Date().toLocaleDateString('ko-KR').replace(/\s/g, '')}.pdf`);
            } catch (error) {
                console.error("Error generating PDF:", error);
                alert("PDF 생성 중 오류 발생: " + error.message);
            } finally {
                document.querySelectorAll('.no-print').forEach(btn => btn.style.display = '');
                if (detailContentArea) { // detailContentArea가 유효한지 확인 후 스타일 복원
                    detailContentArea.style.cssText = originalDetailContentAreaStyle;
                }
            }
          };
          
          const renderResponseItem = (word, index) => {
            const response = responses[word.id];
            let responseText = '미응답'; 
            let responseColor = 'text-gray-500';
            const notesExist = response && response.notes && response.notes.trim() !== '';

            if (response && typeof response.isCorrect === 'boolean') {
                if (response.isCorrect) {
                    responseText = '정반응';
                    responseColor = 'text-green-700';
                } else {
                    responseText = '오반응';
                    responseColor = 'text-red-700';
                }
            } else if (notesExist) { 
                responseText = '반응 기록 없음 (노트만 있음)';
            } else { 
                return null; 
            }

            return (
              <div key={word.id} className="p-3 bg-gray-100 rounded-lg shadow-sm text-sm break-words response-item-pdf">
                <p className="text-gray-800 leading-relaxed">
                  <span className="font-semibold">{index + 1}. {word.word}</span>
                  <span className="text-gray-600"> ({word.pronunciation})</span>
                  {word.rule && <span className="text-xs text-blue-600 ml-1">[{word.rule}]</span>}
                  <span className="mx-1">-</span>
                  학생 반응: <span className={`font-medium ${responseColor}`}>{responseText}</span>
                  {notesExist && <span className="text-gray-600"> (기록: {response.notes.trim()})</span>}
                </p>
              </div>
            );
          };

          return (
            <div className="p-6 bg-white rounded-xl shadow-lg w-full max-w-2xl mx-auto my-8">
              {/* 요약 정보 (학생 정보, 영역별 습득 여부, 종합 코멘트) */}
              <div ref={resultsSummaryRef}>
                <h2 className="text-3xl font-bold text-gray-800 mb-6 text-center">검사 결과</h2>
                <div className="mb-6 border-b pb-4">
                  <h3 className="text-xl font-semibold text-gray-700 mb-2">학생 정보</h3>
                  <p className="text-gray-600"><strong>이름:</strong> {personalInfo.name || '미입력'}</p>
                  <p className="text-gray-600"><strong>학년:</strong> {personalInfo.grade || '미입력'}학년</p>
                </div>

                <div className="mb-6 p-4 bg-yellow-50 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-700 mb-2">종합 요약</h3>
                  <p className="text-gray-600">{generateOverallSummaryText()}</p>
                </div>

                <div className="mb-6">
                  <h3 className="text-xl font-semibold text-gray-700 mb-3">영역별 습득 여부</h3>
                  <div className="space-y-3">
                    <div className="flex justify-between items-center bg-blue-50 p-3 rounded-lg">
                      <span className="font-medium text-gray-700">의미 규칙 단어 (받침 없는 단어)</span>
                      <span className={`font-bold ${meaningRegularNoFinalConsonantStats.status === '습득' ? 'text-green-600' : 'text-red-600'}`}>
                        {meaningRegularNoFinalConsonantStats.status} ({meaningRegularNoFinalConsonantStats.correctCount}/{meaningRegularNoFinalConsonantStats.totalCount})
                      </span>
                    </div>
                    <div className="flex justify-between items-center bg-blue-50 p-3 rounded-lg">
                      <span className="font-medium text-gray-700">의미 규칙 단어 (받침 있는 단어)</span>
                      <span className={`font-bold ${meaningRegularWithFinalConsonantStats.status === '습득' ? 'text-green-600' : 'text-red-600'}`}>
                        {meaningRegularWithFinalConsonantStats.status} ({meaningRegularWithFinalConsonantStats.correctCount}/{meaningRegularWithFinalConsonantStats.totalCount})
                      </span>
                    </div>
                    <div className="bg-blue-50 p-3 rounded-lg">
                      <span className="font-medium text-gray-700 block mb-2">의미 불규칙 단어 (음운 변동 규칙별)</span>
                      <ul className="list-disc list-inside space-y-2 ml-4">
                        {irregularResults.map((res, index) => (
                          <li key={index} className="flex justify-between items-center">
                            <span className="text-gray-600">{res.rule}</span>
                            <span className={`font-bold ${res.status === '습득' ? 'text-green-600' : 'text-red-600'}`}>
                              {res.status} ({res.correctCount}/{res.totalCount})
                            </span>
                          </li>
                        ))}
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
              
              {/* 문항별 상세 반응 기록 (이 div 전체가 detailSectionInput으로 캡처됨) */}
              <div ref={resultsDetailRef} className="mt-8 pt-6 border-t">
                <h3 className="text-2xl font-semibold text-gray-800 mb-4 text-center no-print-pdf-title">문항별 상세 반응 기록</h3>
                <div className="pdf-detail-content-area"> {/* 실제 목록 내용 */}
                  <div className="mb-6 break-inside-avoid">
                    <h4 className="text-xl font-semibold text-gray-700 mb-3">의미 규칙 단어 (받침 없는 단어)</h4>
                    <div className="space-y-2">
                      {wordDataFromApp.meaningRegularNoFinalConsonant.map((word, index) => renderResponseItem(word, index)).filter(Boolean)}
                    </div>
                  </div>
                  <div className="mb-6 break-inside-avoid">
                    <h4 className="text-xl font-semibold text-gray-700 mb-3">의미 규칙 단어 (받침 있는 단어)</h4>
                    <div className="space-y-2">
                      {wordDataFromApp.meaningRegularWithFinalConsonant.map((word, index) => renderResponseItem(word, index)).filter(Boolean)}
                    </div>
                  </div>
                  <div className="mb-6 break-inside-avoid">
                    <h4 className="text-xl font-semibold text-gray-700 mb-3">의미 불규칙 단어 (음운 변동 규칙별)</h4>
                    {Object.entries(irregularRules).map(([rule, wordsInSection]) => {
                      const renderedItems = wordsInSection.map((word, index) => renderResponseItem(word, index)).filter(Boolean);
                      if (renderedItems.length === 0) return null; 
                      return (
                        <div key={rule} className="mb-4 break-inside-avoid">
                          <h5 className="text-lg font-medium text-gray-600 mb-2">{rule}</h5>
                          <div className="space-y-2 ml-2 sm:ml-4">{renderedItems}</div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>

              <div className="flex flex-col space-y-4 mt-8 no-print">
                <button onClick={generatePdf} className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg">PDF 파일로 내보내기</button>
                <button onClick={onRestart} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">새로운 검사 시작 (검사 종료)</button>
              </div>
            </div>
          );
        };

        const PastAssessmentsList = ({ pastAssessments, onViewAssessment, onBackToHome }) => {
          return (
            <div className="p-6 bg-white rounded-xl shadow-lg w-full max-w-2xl mx-auto my-8">
              <h2 className="text-2xl font-bold text-gray-800 mb-6 text-center">이전 검사 결과 목록</h2>
              {pastAssessments.length === 0 ? (
                <p className="text-center text-gray-600">저장된 검사 결과가 없습니다.</p>
              ) : (
                <ul className="space-y-3">
                  {pastAssessments.map((assessment) => (
                    <li
                      key={assessment.id}
                      className="p-4 bg-gray-50 rounded-lg shadow-sm flex flex-col sm:flex-row justify-between items-start sm:items-center cursor-pointer hover:bg-gray-100 transition duration-150 ease-in-out"
                      onClick={() => onViewAssessment(assessment)}
                    >
                      <div className="mb-2 sm:mb-0">
                        <p className="font-semibold text-gray-800">
                          {assessment.personalInfo?.name || '알 수 없는 아동'} ({assessment.personalInfo?.grade || '?'}학년)
                        </p>
                        <p className="text-sm text-gray-500">
                          검사일: {assessment.timestamp ? new Date(assessment.timestamp.toDate()).toLocaleDateString('ko-KR') : '날짜 미상'}
                        </p>
                      </div>
                      <span className="text-blue-600 font-medium self-end sm:self-center">상세 보기 &gt;</span>
                    </li>
                  ))}
                </ul>
              )}
              <button onClick={onBackToHome} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg mt-8">홈으로 돌아가기</button>
            </div>
          );
        };

        // --- 메인 App 컴포넌트 ---
        const App = () => {
          const [step, setStep] = useState(0);
          const [personalInfo, setPersonalInfo] = useState({ name: '', grade: '' });
          const [responses, setResponses] = useState({});
          const [firebaseInitialized, setFirebaseInitialized] = useState(false);
          const [userId, setUserId] = useState(null);
          const [pastAssessments, setPastAssessments] = useState([]);
          const [selectedPastAssessment, setSelectedPastAssessment] = useState(null);

          const currentWordData = wordData; 

          useEffect(() => {
            const firebaseConfigJson = JSON.parse(__firebase_config_str || '{}');
            if (Object.keys(firebaseConfigJson).length === 0 && !firebase.apps.length) {
                 console.warn("Firebase config is empty. Firebase will not be initialized.");
                 setFirebaseInitialized(true); 
                 setUserId(crypto.randomUUID()); 
                 return;
            }
            try {
                if (!firebase.apps.length) firebase.initializeApp(firebaseConfigJson);
                else firebase.app();
                
                firebase.auth().setPersistence(firebase.auth.Auth.Persistence.SESSION)
                 .then(() => __initial_auth_token ? firebase.auth().signInWithCustomToken(__initial_auth_token) : firebase.auth().signInAnonymously())
                 .then(uc => setUserId(uc && uc.user ? uc.user.uid : crypto.randomUUID()))
                 .catch(err => {
                    console.error("Firebase Auth Error:", err);
                    firebase.auth().signInAnonymously().then(uc => setUserId(uc && uc.user ? uc.user.uid : crypto.randomUUID())).catch(() => setUserId(crypto.randomUUID()));
                 }).finally(() => setFirebaseInitialized(true));

                const unsubAuth = firebase.auth().onAuthStateChanged(u => setUserId(u ? u.uid : (userId || crypto.randomUUID())));
                return () => unsubAuth();
            } catch (error) {
                console.error("Firebase initialization error:", error);
                setUserId(crypto.randomUUID());
                setFirebaseInitialized(true); 
            }
          }, []); 


          useEffect(() => {
            if (firebaseInitialized && userId && firebase.apps.length && firebase.firestore) {
              const db = firebase.firestore();
              const assessmentsCollectionPath = `artifacts/${__app_id}/users/${userId}/assessments`;
              const unsubscribe = db.collection(assessmentsCollectionPath).orderBy("timestamp", "desc")
                .onSnapshot(snapshot => setPastAssessments(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))),
                error => console.error(`Error fetching:`, error));
              return () => unsubscribe();
            }
          }, [firebaseInitialized, userId]);

          const saveAssessment = async () => {
            if (!firebaseInitialized || !userId || !firebase.apps.length || !firebase.firestore) {
              alert("데이터베이스에 연결되지 않아 저장할 수 없습니다."); return false;
            }
            const db = firebase.firestore();
            const assessmentToSave = { personalInfo, responses, timestamp: firebase.firestore.FieldValue.serverTimestamp() };
            const path = `artifacts/${__app_id}/users/${userId}/assessments`;
            try {
              await db.collection(path).add(assessmentToSave);
              alert("검사 결과가 성공적으로 저장되었습니다."); return true;
            } catch (e) {
              alert(`저장 중 오류: ${e.message}`); return false;
            }
          };

          const handleNextStep = () => { if (step === 4) saveAssessment(); setStep(prev => prev + 1); };
          const handlePreviousStep = () => setStep(prev => prev - 1);
          const handleRestart = () => { setStep(0); setPersonalInfo({ name: '', grade: '' }); setResponses({}); setSelectedPastAssessment(null); };
          const handleViewPastAssessment = (assessment) => { setSelectedPastAssessment(assessment); setStep(7); };
          const handleBackToHome = () => { setStep(0); setSelectedPastAssessment(null); setPersonalInfo({ name: '', grade: '' }); setResponses({}); };

          const renderStepContent = () => {
            switch (step) {
              case 0: return <Introduction onStart={() => {
                        if (!firebaseInitialized && Object.keys(JSON.parse(__firebase_config_str || '{}')).length > 0) { 
                            alert("도구가 아직 로딩 중입니다. 잠시 후 다시 시도해주세요."); return;
                        } handleNextStep(); }} />;
              case 1: return <PersonalInfo personalInfo={personalInfo} setPersonalInfo={setPersonalInfo} onNext={handleNextStep} />;
              case 2: return <WordSection title="의미 규칙 단어 (받침 없는 단어)" description="모음 및 자음 인식 능력을 확인합니다." words={currentWordData.meaningRegularNoFinalConsonant} responses={responses} setResponses={setResponses} onNext={handleNextStep} onPrevious={handlePreviousStep} />;
              case 3: return <WordSection title="의미 규칙 단어 (받침 있는 단어)" description="받침 있는 단어의 인식 능력을 확인합니다." words={currentWordData.meaningRegularWithFinalConsonant} responses={responses} setResponses={setResponses} onNext={handleNextStep} onPrevious={handlePreviousStep} />;
              case 4: return <WordSection title="의미 불규칙 단어 (음운 변동 규칙)" description="음운 변동 규칙 적용 단어의 인식 능력을 확인합니다." words={currentWordData.meaningIrregular} responses={responses} setResponses={setResponses} onNext={handleNextStep} onPrevious={handlePreviousStep} />;
              case 5: return <Results personalInfo={personalInfo} responses={responses} onRestart={handleRestart} wordDataFromApp={currentWordData} />;
              case 6: return <PastAssessmentsList pastAssessments={pastAssessments} onViewAssessment={handleViewPastAssessment} onBackToHome={handleBackToHome} />;
              case 7: if (selectedPastAssessment) return <Results personalInfo={selectedPastAssessment.personalInfo} responses={selectedPastAssessment.responses} onRestart={handleBackToHome} wordDataFromApp={currentWordData} />;
                        handleBackToHome(); return null;
              default: return <Introduction onStart={handleNextStep} />;
            }
          };
          
          if (Object.keys(JSON.parse(__firebase_config_str || '{}')).length > 0 && !firebaseInitialized && step !== 0) {
             return <div className="loading-message">검사 도구를 불러오는 중입니다... (Firebase 초기화 대기)</div>;
          }

          return <React.Fragment>{renderStepContent()}</React.Fragment>;
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
